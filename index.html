<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Crochet Round ‚Äî Spot the SC</title>
<style>
  :root{ --pink:#e91e63; --gold:#ffd700; --black:#111827; --beige:#f5f5dc; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: Georgia,"Times New Roman",serif;
    background-image:url('https://wallpapers.com/images/hd/kate-spade-white-hearts-erxoa1ltp1qmbwnn.jpg');
    background-size:cover;background-position:center;
    display:flex;align-items:flex-start;justify-content:center;
  }
  .wrap{ width:min(92vw,1000px); margin:clamp(12px,2.5vh,20px) auto 40px; }
  .hud{
    display:flex;gap:12px;align-items:center;justify-content:center;
    background:#fff;padding:10px 12px;border-radius:14px;
    border:2px solid var(--gold); box-shadow:0 6px 18px rgba(0,0,0,.06);
  }
  .chip{font-weight:700;color:var(--black)}
  .btn{ border:2px solid var(--black); background:var(--black); color:#fff;
        border-radius:12px; padding:8px 14px; font-weight:600; cursor:pointer; }
  .btn:active{transform:translateY(1px)}
  .stage{
    position:relative; margin:18px auto 0;
    border-radius:22px; background:var(--beige);
    box-shadow:0 10px 28px rgba(0,0,0,.10);
    width:100%; aspect-ratio:1/1; overflow:hidden;
  }
  .round-tag{
    position:absolute; top:8px; left:8px; z-index:4;
    background:#fff; border:1.5px solid var(--gold); color:var(--black);
    font-size:12px; padding:4px 10px; border-radius:999px;
    box-shadow:0 2px 8px rgba(0,0,0,.05);
  }
  .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.4);
            display:none; align-items:center; justify-content:center; padding:16px; }
  .overlay.show{display:flex}
  .card{
    background:#fff; color:var(--black);
    border-radius:18px; border:3px solid var(--gold);
    padding:22px; width:min(92vw,520px); text-align:center;
    box-shadow:0 18px 38px rgba(0,0,0,.18);
  }
  .card .row{margin-top:14px; display:flex; gap:10px; justify-content:center}
  .small-note{font-size:12px; color:#333; text-align:center; margin-top:10px}
  .spark line{stroke:var(--gold); stroke-width:2}
  .spark{animation:pop .6s ease-out forwards}
  @keyframes pop{ from{transform:scale(.1); opacity:.0} to{transform:scale(1); opacity:1} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud" id="hud">
      <div class="chip">Round <span id="roundNow" style="color:var(--pink)">1</span>/5</div>
      <div class="chip">Stitches <span id="stCount">12</span></div>
      <button class="btn" id="startBtn">Start</button>
      <button class="btn" id="pauseBtn" style="display:none">Pause</button>
    </div>

    <div class="stage" id="stage">
      <div class="round-tag" id="roundTag">Round 1</div>
      <svg id="svg" viewBox="0 0 1000 1000" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <p class="small-note">
      Move/drag the <b>hook</b> over a stitch to highlight it. On phone, the stitch
      selects the moment the hook touches it. Finish R1‚ÄìR5 to complete the cat base.
    </p>
  </div>

  <div class="overlay" id="endOverlay" aria-hidden="true">
    <div class="card">
      <h2>Cat complete! üê±‚ú®</h2>
      <p>You finished Round 5. Beautiful work!</p>
      <div class="row">
        <button class="btn" id="closeEnd">Close</button>
        <button class="btn" id="againEnd">Play again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const GOLD = css('--gold'), BLACK = css('--black'), PINK = css('--pink');
  const svg = document.getElementById('svg');
  const stCountEl = document.getElementById('stCount');
  const roundNowEl = document.getElementById('roundNow');
  const roundTag = document.getElementById('roundTag');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const endOverlay = document.getElementById('endOverlay');
  const againEnd = document.getElementById('againEnd');
  const closeEnd = document.getElementById('closeEnd');

  const END_ROUND = 5;
  const CX = 500, CY = 500;

  let running = false;
  let round = 1;
  let ringR = 420;
  let stitches = [];
  let hoverId = null;
  let isPointerDown = false;
  let lastPointerType = 'mouse';
  let lastAutoId = null, lastAutoAt = 0;
  let currentPointer = null;

  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  const toRad = d => (d*Math.PI)/180;
  const dist2 = (x1,y1,x2,y2) => (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
  function pointOnRingDeg(deg, r=ringR){
    const a=toRad(deg); return {x:CX + r*Math.cos(a), y:CY + r*Math.sin(a)};
  }
  function stitchPath(kind){
    let W=44, H=56;
    if(kind==='too_wide') W*=1.3;
    if(kind==='too_shallow') H*=0.75;
    const bl={x:0,y:0}, tl={x:-W/2,y:-H}, tr={x:W/2,y:-H};
    return `M ${bl.x} ${bl.y} L ${tl.x} ${tl.y} M ${bl.x} ${bl.y} L ${tr.x} ${tr.y}`;
  }
  function countForRound(r){ return [0,12,18,24,30,36][r] ?? 36; }
  function radiusForRound(r){ return 330 + r*18; }

  function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
  function addEl(tag, attrs, parent=svg){
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    parent.appendChild(el); return el;
  }

  function drawFrame(){
    clearSvg();
    addEl('circle', {cx:CX,cy:CY,r:ringR+140,fill:'none',stroke:GOLD,'stroke-width':4});
    addEl('circle', {cx:CX,cy:CY,r:ringR-150,fill:'none',stroke:'#e9ebef','stroke-dasharray':'5 14'});

    const ordered=[...stitches].sort((a,b)=>a.angle-b.angle);
    for(const s of ordered){
      const base = pointOnRingDeg(s.angle);
      const inwardDeg = s.angle+180;
      const rot = (s.kind==='wrong_orient')? s.angle+90 : inwardDeg;

      const isHover = (hoverId===s.id && !s.clicked);
      const stroke = s.clicked? (s.kind==='real'? GOLD : '#F8BBD0') : (isHover? PINK : BLACK);
      const sw = isHover? 8 : 6;

      const g = addEl('g', {transform:`translate(${base.x},${base.y}) rotate(${rot})`, 'data-id':s.id});
      const p = addEl('path', {d:stitchPath(s.kind), fill:'none', stroke, 'stroke-width':sw, 'stroke-linecap':'round'}, g);
      if(isHover) p.style.filter = `drop-shadow(0 0 8px ${GOLD})`;
    }

    if(currentPointer){
      const imgW = 140, imgH = 140;
      addEl('image',{
        href:'https://athriftynotion.com/cdn/shop/files/SizeNCrochetHook_800x.png?v=1753294266',
        x: currentPointer.x - imgW*0.4,
        y: currentPointer.y - imgH*0.4,
        width: imgW, height: imgH, 'pointer-events':'none'
      });
    }
  }

  function genRound(r){
    const c = countForRound(r);
    stitches = Array.from({length:c}, (_,i)=>{
      const baseAngle = (360/c)*i - 90 + 5;
      const rr = Math.random();
      const kind = rr<0.72 ? 'real' : rr<0.84 ? 'wrong_orient' : rr<0.93 ? 'too_wide' : 'too_shallow';
      return {id:i, angle:baseAngle, kind, clicked:false};
    });
    ringR = radiusForRound(r);
    roundTag.textContent = `Round ${round}`;
    roundNowEl.textContent = String(round);
    stCountEl.textContent = String(c);
    drawFrame();
  }

  function start(){
    running = true;
    startBtn.style.display='none';
    pauseBtn.style.display='inline-block';
    round = 1; genRound(round);
    endOverlay.classList.remove('show');
    currentPointer = null; hoverId=null;
  }
  function pause(){
    running = false;
    startBtn.textContent='Resume';
    startBtn.style.display='inline-block';
    pauseBtn.style.display='none';
  }
  function remainingReal(){ return stitches.filter(s=>s.kind==='real' && !s.clicked).length; }

  function selectStitch(s){
    if(!running || !s || s.clicked) return;
    s.clicked = true;
    sparkleAt(s);
    drawFrame();
    if(remainingReal()===0){
      if(round>=5){
        running=false;
        pauseBtn.style.display='none';
        startBtn.textContent='Play again';
        startBtn.style.display='inline-block';
        endOverlay.classList.add('show');
      }else{
        round++; genRound(round);
      }
    }
  }

  function sparkleAt(s){
    const base = pointOnRingDeg(s.angle);
    const g = addEl('g', {'class':'spark'});
    const rays = 8, R = 28;
    for(let i=0;i<rays;i++){
      const a = i*2*Math.PI/rays;
      const x2= base.x + R*Math.cos(a), y2= base.y + R*Math.sin(a);
      const ln = addEl('line',{x1:base.x,y1:base.y,x2,y2}, g);
      ln.style.animationDelay = (i*0.02)+'s';
    }
    setTimeout(()=>{ if(g && g.parentNode) g.parentNode.removeChild(g); }, 600);
  }

  function svgPointFromEvent(ev){
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const m = svg.getScreenCTM().inverse();
    const r = pt.matrixTransform(m);
    return {x:r.x, y:r.y};
  }

  function nearestStitch(mx,my, snap=58){
    const snap2 = snap*snap;
    let best=null, bestD2=Infinity;
    for(const s of stitches){
      const b = pointOnRingDeg(s.angle);
      const d2 = dist2(mx,my,b.x,b.y);
      if(d2<bestD2){ bestD2=d2; best=s; }
    }
    return {best, within: bestD2<snap2};
  }

  function updateHover(mx,my){
    const {best, within} = nearestStitch(mx,my, 58);
    hoverId = (within && best && !best.clicked) ? best.id : null;
    currentPointer = {x:mx,y:my};
    drawFrame();
  }

  function maybeAutoSelectOnTouch(mx,my){
    if(!running) return;
    const snap = (window.innerWidth < 480) ? 76 : 66;
    const {best, within} = nearestStitch(mx,my, snap);
    const now = Date.now();
    if(within && best && !best.clicked){
      if(best.id !== lastAutoId || (now-lastAutoAt)>80){
        selectStitch(best);
        lastAutoId = best.id; lastAutoAt = now;
      }
    }
  }

  function selectAtScreenEvent(ev){
    const p = svgPointFromEvent(ev);
    const {best, within} = nearestStitch(p.x,p.y, 58);
    if(within && best) selectStitch(best);
  }

  svg.addEventListener('pointerdown',(ev)=>{
    if(ev.isPrimary===false) return;
    lastPointerType = ev.pointerType || 'mouse';
    isPointerDown = true;
    try{ svg.setPointerCapture(ev.pointerId); }catch(_){}
    const p = svgPointFromEvent(ev);
    updateHover(p.x,p.y);
    if(lastPointerType==='touch'){ maybeAutoSelectOnTouch(p.x,p.y); }
    ev.preventDefault();
  },{passive:false});

  svg.addEventListener('pointermove',(ev)=>{
    if(ev.isPrimary===false) return;
    lastPointerType = ev.pointerType || lastPointerType;
    const p = svgPointFromEvent(ev);
    updateHover(p.x,p.y);
    if(isPointerDown && lastPointerType==='touch'){
      maybeAutoSelectOnTouch(p.x,p.y);
      ev.preventDefault();
    }
  },{passive:false});

  svg.addEventListener('pointerup',(ev)=>{
    if(ev.isPrimary===false) return;
    isPointerDown = false;
    try{ svg.releasePointerCapture(ev.pointerId); }catch(_){}
    if(lastPointerType!=='touch'){ selectAtScreenEvent(ev); }
    ev.preventDefault();
  },{passive:false});

  svg.addEventListener('pointerleave',()=>{
    isPointerDown=false; hoverId=null; currentPointer=null; drawFrame();
  });

  startBtn.addEventListener('click', ()=>{
    if(!running && round>1 && remainingReal()>0){
      running=true; startBtn.style.display='none'; pauseBtn.style.display='inline-block'; return;
    }
    start();
  });
  pauseBtn.addEventListener('click', pause);
  againEnd.addEventListener('click', ()=>{ endOverlay.classList.remove('show'); start(); });
  closeEnd.addEventListener('click', ()=>{ endOverlay.classList.remove('show'); });

  // initial board (idle)
  genRound(1); running=false; startBtn.style.display='inline-block'; pauseBtn.style.display='none';
})();
</script>
</body>
</html>
