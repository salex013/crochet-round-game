<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Crochet Round ‚Äî Spot the SC</title>
<style>
  :root{ --pink:#E91E63; --gold:#FFD700; --black:#111827; --beige:#f5f5dc; }
  *{ box-sizing:border-box }
  html,body{ height:100%; margin:0 }
  body{
    overflow:auto;
    font-family: Georgia, "Times New Roman", serif;
    background-image:url('https://wallpapers.com/images/hd/kate-spade-white-hearts-erxoa1ltp1qmbwnn.jpg');
    background-size:cover; background-position:center;
    display:flex; align-items:center; justify-content:center;
    padding: clamp(10px, 2.5vmin, 28px);
    padding-left: max(10px, env(safe-area-inset-left));
    padding-right:max(10px, env(safe-area-inset-right));
    padding-top:  max(10px, env(safe-area-inset-top));
    padding-bottom:max(10px, env(safe-area-inset-bottom));
  }

  .wrap{
    width:100%; max-width:900px;
    display:flex; flex-direction:column; align-items:center; gap:14px;
    padding-inline: clamp(10px, 2.5vmin, 28px);
  }
  h1{ margin:0; color:var(--black); font-size:26px; letter-spacing:.02em; text-align:center }

  .bar{ display:flex; flex-wrap:wrap; align-items:center; gap:14px; background:#fff;
        border:2px solid var(--gold); padding:8px 12px; border-radius:14px; box-shadow:0 4px 18px rgba(0,0,0,.08) }
  .pill{ font-weight:700; color:var(--black); font-size:14px } .pill .v{ color:var(--pink) }
  button{ background:var(--black); color:#fff; border:2px solid var(--black); border-radius:12px; padding:8px 14px; cursor:pointer; font-weight:700 }
  button:hover{ border-color:var(--gold) }

  .stage{ position:relative; width:100%; display:flex; justify-content:center; overflow:visible; }
  .tag{ position:absolute; top:-26px; left:8px; font-size:12px; background:#fff; border:1.5px solid var(--gold);
        color:var(--black); padding:4px 10px; border-radius:999px; box-shadow:0 2px 8px rgba(0,0,0,.06) }

  /* The board‚Äôs *width* is controlled by JS for perfect fit. Height follows aspect-ratio. */
  svg.board{
    aspect-ratio: 640 / 720;     /* exact proportion */
    width: 600px;                /* placeholder; JS will set a precise width */
    height: auto;
    background: var(--beige);
    border-radius: 18px;
    box-shadow: 0 10px 24px rgba(0,0,0,.12);
    touch-action: none; -ms-touch-action: none;
    overflow: visible;
  }

  .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; padding:16px }
  .overlay.show{ display:flex }
  .card{ background:#fff; border:3px solid var(--gold); color:var(--black); border-radius:18px; box-shadow:0 12px 28px rgba(0,0,0,.18);
         padding:20px; max-width:520px; width:100%; text-align:center }
  .card h2{ margin:8px 0 6px 0 } .row{ display:flex; justify-content:center; gap:12px; margin-top:12px }

  .note{ font-size:12px; max-width:640px; text-align:center; color:var(--black) }
  .spark line,.spark circle{ animation:fadeIn .6s ease-out forwards } .spark line{ opacity:0 } @keyframes fadeIn{ to{opacity:1} }
  .noselect{ -webkit-user-select:none; user-select:none }
  @media (max-width: 420px){ h1{ font-size:20px } }
</style>
</head>
<body>
  <div class="wrap" id="wrap">
    <h1 class="noselect" id="title">Crochet Round ‚Äî Spot the SC</h1>

    <div class="bar noselect" id="bar">
      <div class="pill">Round <span class="v" id="ui-round">1</span>/<span>5</span></div>
      <div class="pill">Stitches <span id="ui-count">12</span></div>
      <button id="btn-start">Start</button>
      <button id="btn-pause" style="display:none">Pause</button>
    </div>

    <div class="stage" id="stage">
      <div class="tag noselect" id="round-tag">Round 1</div>
      <svg id="svg" class="board" width="640" height="720" viewBox="0 0 640 720" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <p class="note" id="note">Drag the <b>hook</b> with your finger to highlight a stitch, or just <b>tap</b> near one.
      Lift your finger (or dwell briefly) to select. Finishing all ‚ÄúV‚Äù stitches advances the round.</p>
  </div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h2>Cat complete! üê±‚ú®</h2>
      <p>You finished Round 5 (R1‚ÄìR5). Beautiful work!</p>
      <div class="row">
        <button id="btn-close">Close</button>
        <button id="btn-again">Play again</button>
      </div>
    </div>
  </div>

<script>
(function(){
  const PINK="#E91E63", GOLD="#FFD700", BLACK="#111827";
  const WIDTH=640, HEIGHT=720, RATIO=WIDTH/HEIGHT, cx=WIDTH/2, cy=340, END_ROUND=5;

  // elements
  const roundEl = document.getElementById('ui-round');
  const countEl = document.getElementById('ui-count');
  const startBtn = document.getElementById('btn-start');
  const pauseBtn = document.getElementById('btn-pause');
  const tagEl = document.getElementById('round-tag');
  const svg = document.getElementById('svg');
  const overlay = document.getElementById('overlay');
  const closeBtn = document.getElementById('btn-close');
  const againBtn = document.getElementById('btn-again');
  const titleEl = document.getElementById('title');
  const barEl = document.getElementById('bar');
  const noteEl = document.getElementById('note');
  const stageEl = document.getElementById('stage');
  const wrapEl = document.getElementById('wrap');

  // ----- smart sizing so NOTHING clips on desktop or phone -----
  function sizeBoard(){
    // Horizontal cap
    const maxByWidth = Math.min(wrapEl.clientWidth, window.innerWidth*0.92, 1000);

    // Vertical cap: available height minus everything above/below the board
    const bodyPadTop = parseFloat(getComputedStyle(document.body).paddingTop) || 0;
    const bodyPadBottom = parseFloat(getComputedStyle(document.body).paddingBottom) || 0;

    const above = titleEl.getBoundingClientRect().height + 8
                + barEl.getBoundingClientRect().height + 14
                + 26; // little space for the round tag

    const below = 12 + noteEl.getBoundingClientRect().height;

    // Use small viewport height when supported
    const viewH = Math.min(
      (window.innerHeight || 0),
      (window.visualViewport ? window.visualViewport.height : window.innerHeight || 0)
    );

    const availH = Math.max(0,
      viewH - (bodyPadTop + bodyPadBottom + above + below)
    );

    // Width that would fit within the available height, respecting aspect ratio
    const maxByHeight = availH * RATIO;

    // Final width: min of horizontal limit, vertical limit, and a hard max pixel size
    const finalW = Math.max(280, Math.min(maxByWidth, maxByHeight, 780)); // 780px hard cap looks great on desktop
    svg.style.width = finalW + 'px';
  }

  // Resize on load, resize, orientation, font load jitter
  window.addEventListener('load', sizeBoard);
  window.addEventListener('resize', sizeBoard);
  window.addEventListener('orientationchange', ()=>setTimeout(sizeBoard, 50));
  // in case fonts/layout shift after paint
  setTimeout(sizeBoard, 100);
  setTimeout(sizeBoard, 400);

  // ----- game logic (unchanged selection improvements) -----
  let running=false, round=1, stitches=[], ringR=160;
  let hoverId=null, pointerPos=null, isPointerDown=false;
  let dwellTimer=null, lastDownHover=null;

  const counts=[0,12,18,24,30,36];
  const toRad=d=>d*Math.PI/180;
  const pointOnRingDeg=(deg,r=ringR)=>({x:cx+r*Math.cos(toRad(deg)), y:cy+r*Math.sin(toRad(deg))});
  const dist2=(x1,y1,x2,y2)=> (x1-x2)**2+(y1-y2)**2;
  const radiusForRound=r=>130+r*8;

  function stitchPath(kind){
    let W=44,H=56;
    if(kind==='too_wide') W*=1.3;
    if(kind==='too_shallow') H*=0.75;
    const bl={x:0,y:0}, tl={x:-W/2,y:-H}, tr={x:W/2,y:-H};
    return `M ${bl.x} ${bl.y} L ${tl.x} ${tl.y} M ${bl.x} ${bl.y} L ${tr.x} ${tr.y}`;
  }

  function genRound(r){
    const c=counts[r]||36;
    ringR = radiusForRound(r);
    stitches = Array.from({length:c},(_,i)=>{
      const a=(360/c)*i - 90 + 5;
      const rr=Math.random();
      const kind = rr<0.72?'real' : rr<0.84?'wrong_orient' : rr<0.93?'too_wide':'too_shallow';
      return {id:i, angle:a, kind, clicked:false};
    });
    roundEl.textContent=r;
    tagEl.textContent=`Round ${r}`;
    countEl.textContent=c;
    draw();
    sizeBoard();
  }

  function start(){
    round=1; running=true; hoverId=null; pointerPos=null;
    startBtn.style.display='none'; pauseBtn.style.display='inline-block';
    startBtn.textContent='Start';
    genRound(1);
  }
  function pause(){
    running=false;
    startBtn.textContent='Resume';
    startBtn.style.display='inline-block';
    pauseBtn.style.display='none';
  }

  function circle(x,y,r,fill,stroke,sw){
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',r);
    c.setAttribute('fill',fill); c.setAttribute('stroke',stroke); c.setAttribute('stroke-width',sw);
    return c;
  }

  function sparkle(x,y){
    const rays=8, radius=18;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('class','spark');
    for(let i=0;i<rays;i++){
      const a = i*2*Math.PI/rays, x2=x+radius*Math.cos(a), y2=y+radius*Math.sin(a);
      const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
      ln.setAttribute('x1',x); ln.setAttribute('y1',y); ln.setAttribute('x2',x2); ln.setAttribute('y2',y2);
      ln.setAttribute('stroke',GOLD); ln.setAttribute('stroke-width',2);
      ln.style.animationDelay=(0.03*i)+'s'; g.appendChild(ln);
    }
    const dot=document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',x); dot.setAttribute('cy',y); dot.setAttribute('r',4); dot.setAttribute('fill',GOLD); g.appendChild(dot);
    svg.appendChild(g); setTimeout(()=>g.remove(),700);
  }

  function remainingReal(){ return stitches.filter(s=>s.kind==='real' && !s.clicked).length; }
  function checkEnd(){
    if(!running) return;
    if(stitches.length>0 && remainingReal()===0){
      if(round>=END_ROUND){
        running=false; startBtn.textContent='Start'; startBtn.style.display='inline-block'; pauseBtn.style.display='none';
        overlay.classList.add('show');
      } else { round++; genRound(round); }
    }
  }

  function selectStitch(s){
    if(!running || !s || s.clicked) return;
    s.clicked=true;
    if(s.kind==='real'){ const b=pointOnRingDeg(s.angle, ringR); sparkle(b.x, b.y-18); }
    draw(); checkEnd();
  }

  function draw(){
    while(svg.firstChild) svg.firstChild.remove();
    svg.appendChild(circle(cx,cy, ringR+70,'none',GOLD,2));
    const inner=circle(cx,cy, ringR-70,'none','#f3f4f6',2); inner.setAttribute('stroke-dasharray','3 8'); svg.appendChild(inner);

    const ordered=[...stitches].sort((a,b)=>a.angle-b.angle);
    for(const s of ordered){
      const base=pointOnRingDeg(s.angle, ringR);
      const inwardDeg=s.angle+180;
      const rotDeg=(s.kind==='wrong_orient')? s.angle+90 : inwardDeg;
      const d=stitchPath(s.kind);
      const isHover=(hoverId===s.id) && !s.clicked;
      const strokeColor = s.clicked ? (s.kind==='real'?GOLD:'#F8BBD0') : isHover?PINK:BLACK;
      const strokeW = isHover ? 5.5 : 4;

      const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.style.cursor='pointer';
      const path=document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d',d);
      path.setAttribute('transform',`translate(${base.x},${base.y}) rotate(${rotDeg})`);
      path.setAttribute('fill','none'); path.setAttribute('stroke',strokeColor);
      path.setAttribute('stroke-width',strokeW); path.setAttribute('stroke-linecap','round');
      if(isHover) path.style.filter=`drop-shadow(0 0 6px ${GOLD})`;
      g.addEventListener('click',()=>selectStitch(s));  // desktop fallback
      svg.appendChild(g); g.appendChild(path);
    }

    if(pointerPos){
      const img=document.createElementNS('http://www.w3.org/2000/svg','image');
      img.setAttributeNS('http://www.w3.org/1999/xlink','href','https://athriftynotion.com/cdn/shop/files/SizeNCrochetHook_800x.png?v=1753294266');
      const hookW = (window.innerWidth<420)? 110:100;
      img.setAttribute('x',pointerPos.x-40); img.setAttribute('y',pointerPos.y-40);
      img.setAttribute('width',hookW); img.setAttribute('height',hookW);
      img.setAttribute('pointer-events','none'); svg.appendChild(img);
    }
  }

  // pointer helpers
  const svgPointFromEvent=(ev)=>{
    const rect=svg.getBoundingClientRect();
    const vb=svg.viewBox.baseVal;
    const scaleX = vb.width/rect.width;
    const scaleY = vb.height/rect.height;
    return { x:(ev.clientX-rect.left)*scaleX, y:(ev.clientY-rect.top)*scaleY };
  };
  const nearestStitch=(mx,my,snapPx)=>{
    const snap2=snapPx*snapPx;
    let best=null, bestD2=Infinity;
    for(const s of stitches){
      const b=pointOnRingDeg(s.angle, ringR);
      const d2=dist2(mx,my,b.x,b.y);
      if(d2<bestD2){ bestD2=d2; best=s; }
    }
    return {best, bestD2, within: bestD2<=snap2};
  };
  function updateHover(mx,my){
    pointerPos={x:mx,y:my};
    const snap = (window.innerWidth<480)? 58 : 38;
    const {best, within} = nearestStitch(mx,my,snap);
    hoverId = within && best ? best.id : (best ? best.id : null);
    draw();
  }
  function selectAtScreenEvent(ev) {
    if (!running) return;
    if (hoverId != null) {
      const s1 = stitches.find(st => st.id === hoverId);
      if (s1) { selectStitch(s1); return; }
    }
    const p = svgPointFromEvent(ev);
    const generous = (window.innerWidth < 480) ? 85 : 50;
    const { best } = nearestStitch(p.x, p.y, generous);
    if (best) { selectStitch(best); return; }
    if (pointerPos) {
      const { best: best2 } = nearestStitch(pointerPos.x, pointerPos.y, generous);
      if (best2) selectStitch(best2);
    }
  }

  // dwell-to-select
  function startDwell(){
    clearTimeout(dwellTimer);
    lastDownHover = hoverId;
    dwellTimer = setTimeout(()=>{
      if (isPointerDown && running) {
        const s = (lastDownHover!=null) ? stitches.find(st=>st.id===lastDownHover) : null;
        if (s && !s.clicked) selectStitch(s);
      }
    }, 170);
  }
  function cancelDwell(){ clearTimeout(dwellTimer); dwellTimer=null; }

  // pointer events
  let isPointerDown=false;
  svg.addEventListener('pointerdown',(ev)=>{
    if(ev.isPrimary===false) return;
    isPointerDown=true;
    try { svg.setPointerCapture(ev.pointerId); } catch(_) {}
    const p=svgPointFromEvent(ev);
    updateHover(p.x,p.y);
    startDwell();
    ev.preventDefault();
  },{passive:false});

  svg.addEventListener('pointermove',(ev)=>{
    if(ev.isPrimary===false) return;
    const p=svgPointFromEvent(ev);
    updateHover(p.x,p.y);
    if(isPointerDown) startDwell();
    if(isPointerDown) ev.preventDefault();
  },{passive:false});

  svg.addEventListener('pointerup',(ev)=>{
    if(ev.isPrimary===false) return;
    isPointerDown=false;
    cancelDwell();
    try { svg.releasePointerCapture(ev.pointerId); } catch(_) {}
    selectAtScreenEvent(ev);
    ev.preventDefault();
  },{passive:false});

  svg.addEventListener('pointerleave',()=>{
    pointerPos=null; hoverId=null; cancelDwell(); draw();
  });

  // extra fallbacks
  svg.addEventListener('click', (ev) => { selectAtScreenEvent(ev); });
  window.addEventListener('pointerup', (ev) => { selectAtScreenEvent(ev); }, { passive:false });
  document.addEventListener('pointerup', (ev) => { selectAtScreenEvent(ev); }, { passive:false });

  // UI
  startBtn.addEventListener('click',()=>{ if(!running) start(); });
  pauseBtn.addEventListener('click',()=>pause());
  closeBtn.addEventListener('click',()=>overlay.classList.remove('show'));
  againBtn.addEventListener('click',()=>{ overlay.classList.remove('show'); start(); });

  // init
  genRound(1); running=false; startBtn.style.display='inline-block'; pauseBtn.style.display='none';
})();
</script>
</body>
</html>
